/*
 * =====================================================================================
 *
 *       Filename:  Euler61.cpp
 *
 *    Description:  Solution to Project Euler, Problem 61
 *
 *        Version:  1.0
 *        Created:  9/6/2016 9:49:25 PM
 *       Revision:  none
 *       Compiler:  g++
 *
 *         Author:  Andrew Epstein
 *        Problem:  Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 *
 *                  Triangle		P3,n=n(n+1)/2		1, 3, 6, 10, 15, ...
 *                  Square		P4,n=n²			1, 4, 9, 16, 25, ...
 *                  Pentagonal		P5,n=n(3n−1)/2		1, 5, 12, 22, 35, ...
 *                  Hexagonal		P6,n=n(2n−1)		1, 6, 15, 28, 45, ...
 *                  Heptagonal		P7,n=n(5n−3)/2		1, 7, 18, 34, 55, ...
 *                  Octagonal		P8,n=n(3n−2)		1, 8, 21, 40, 65, ...
 *
 *                  The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 *                  The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 *                  Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 *                  This is the only set of 4-digit numbers with this property.
 *                  Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
 *                  triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 *         Answer:  28684
 * =====================================================================================
 */

#include "../helper.hpp"

// This will be a dictionary with keys of tuples, and values of vectors of tuples.
// It will let us look up candidates for the next value in the chain
// Example: ds[( 5, 1926 )] == { ( 8, 2640 ), ( 7, 2673 ), ( 3, 2628 ) }
map<tuple<int, int>, vector<tuple<int, int>>> ds;

// p is a list of ( type, data ) tuples where type is the type of number, and data is the number itself
vector<tuple<int, int>> p;

int next( vector<int> types, vector<int> data ) {
	// We have 6 numbers and the chain is complete, so return
	if( types.size() == 6 && data[0] / 100 == data.back() % 100 ) {
		return sum( data );
	}

	for( auto && tuple : ds[make_tuple( types.back(), data.back() )] ) {
		// If we don't already have a number of this type in data,
		// try adding this number to the chain, recursively
		if( find( types.begin(), types.end(), get<0>( tuple ) ) == types.end() ) {
			types.push_back( get<0>( tuple ) );
			data.push_back( get<1>( tuple ) );
			// Pass by value, i.e. create a copy
			return next( types, data );
		}
	}

	return 0;
}

int solve61() {
	// Construct p
	for( int n = 19; n <= 141; ++n ) {
		for( int i = 3; i <= 8; ++i ) {
			int tmp = figurateNumber( i, n );

			// discard if it's not a 4-digit number, or if it is of the form xx0x
			if( 1000 <= tmp && tmp <= 10000 && tmp % 100 > 9 ) {
				p.push_back( make_tuple( i, tmp ) );
			}
		}
	}

	// Construct ds
	for( auto && tuple1 : p ) {
		int type1 = get<0>( tuple1 );
		int data1 = get<1>( tuple1 );

		for( auto && tuple2 : p ) {
			int type2 = get<0>( tuple2 );
			int data2 = get<1>( tuple2 );

			if( type1 != type2 && data1 % 100 == data2 / 100 ) {
				ds[tuple1].push_back( tuple2 );
			}
		}
	}

	// tuple's type is pair<tuple<int, int> const, vector<tuple<int, int>>>
	// it is a pair containing a key and a value
	for( auto && tuple : ds ) {
		vector<int> type = { get<0>( get<0>( tuple ) ) };
		vector<int> data = { get<1>( get<0>( tuple ) ) };
		int result = next( type, data );

		// next() will return 0 if it exhausts all the possible combinations that contain "data" as part of the chain
		if( result != 0 ) {
			return result;
		}
	}

	return 0;
}

