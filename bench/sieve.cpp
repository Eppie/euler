#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#define STEP_CONST 128

int small_primes[343] = {
    2,    3,    5,    7,    11,   13,   17,   19,   23,   29,   31,   37,   41,   43,   47,   53,   59,   61,   67,
    71,   73,   79,   83,   89,   97,   101,  103,  107,  109,  113,  127,  131,  137,  139,  149,  151,  157,  163,
    167,  173,  179,  181,  191,  193,  197,  199,  211,  223,  227,  229,  233,  239,  241,  251,  257,  263,  269,
    271,  277,  281,  283,  293,  307,  311,  313,  317,  331,  337,  347,  349,  353,  359,  367,  373,  379,  383,
    389,  397,  401,  409,  419,  421,  431,  433,  439,  443,  449,  457,  461,  463,  467,  479,  487,  491,  499,
    503,  509,  521,  523,  541,  547,  557,  563,  569,  571,  577,  587,  593,  599,  601,  607,  613,  617,  619,
    631,  641,  643,  647,  653,  659,  661,  673,  677,  683,  691,  701,  709,  719,  727,  733,  739,  743,  751,
    757,  761,  769,  773,  787,  797,  809,  811,  821,  823,  827,  829,  839,  853,  857,  859,  863,  877,  881,
    883,  887,  907,  911,  919,  929,  937,  941,  947,  953,  967,  971,  977,  983,  991,  997,  1009, 1013, 1019,
    1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151,
    1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289,
    1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439,
    1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567,
    1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699,
    1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867,
    1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003,
    2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141,
    2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297,
    2309};

uint64_t maskbits[32] = {0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040,
                         0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000,
                         0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000,
                         0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000,
                         0x10000000, 0x20000000, 0x40000000, 0x80000000};

uint64_t mask_bit_index[2310];

void clear_one_mask_bit( uint64_t *sieve_array, int bit ) {
  uint64_t k = ( bit - 1 ) >> 5;
  sieve_array[k] &= ~( maskbits[( bit - 1 ) & 31] );
}

int test_one_mask_bit( uint64_t *sieve_array, int bit ) {
  uint64_t k = ( bit - 1 ) >> 5;
  return ( sieve_array[k] & ( maskbits[( bit - 1 ) & 31] ) );
}

int main() {
  uint64_t b, j, k;
  uint64_t i;
  uint64_t bit_index = 0;
  uint64_t s, indx;
  uint64_t stop;
  uint64_t *list;

  stop = 100000;
  s = ( stop + 2309 ) / 2310 * 120;

  fprintf( stdout, "attempting to malloc %llu bytes\n", s );
  list = static_cast<uint64_t *>( malloc( s ) );

  memset( list, 0xff, s );

  j = 5;

  /* create array mapping 2310 integers to 480 bits */
  mask_bit_index[0] = bit_index++;
  mask_bit_index[1] = bit_index++;

  for( uint32_t ii = 2; ii < 2310; ii++ ) {
    while( small_primes[j] < ii )
      j++;
    if( ii == small_primes[j]
        || ( ( ii % 2 ) != 0 && ( ii % 3 ) != 0 && ( ii % 5 ) != 0 && ( ii % 7 ) != 0 && ( ii % 11 ) != 0 ) ) {
      mask_bit_index[ii] = bit_index++;
    } else {
      mask_bit_index[ii] = 0;
    }
  }

  indx = 0ULL;

  for( k = 0; k * 2310 < stop; k += STEP_CONST ) {
    for( i = 13; i <= 65536; i += 2 ) {
      b = i % 2310;

      if( mask_bit_index[b] == 0
          || ( i < k * 2310 && ( test_one_mask_bit( &list[i / 2310 * 15], mask_bit_index[b] ) ) == 0 ) ) {
        continue;
      }
      if( k == 0 ) {
        indx = i * i;
      } else {
        indx = ( k * 2310 ) - ( k * 2310 ) % i + i;
      }
      if( ( indx & 1 ) == 0 ) {
        indx += i;
      }
      for( ; indx < ( k + STEP_CONST ) * 2310 && indx <= ( stop + 2309 ) / 2310 * 2310; indx += ( i + i ) ) {
        b = indx % 2310;
        if( mask_bit_index[b] != 0 ) {
          clear_one_mask_bit( &list[indx / 2310 * 15], mask_bit_index[b] );
        }
      }
    }

    for( ; i <= stop && i < ( k + STEP_CONST ) * 2310; i += 2 ) {
      b = i % 2310;
      if( mask_bit_index[b] != 0 && ( test_one_mask_bit( &list[i / 2310 * 15], mask_bit_index[b] ) ) != 0 ) {
        fprintf( stdout, "%10llu\n", i );
      }
    }
  }

  return 0;
}
